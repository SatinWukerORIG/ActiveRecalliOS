import Foundation
import ActivityKit
import UserNotifications

// 1. DATA STRUCTURES
// These must match the "content-state" in your Flask app exactly.
struct RecallAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var question: String
        var progress: Double
    }
    var totalCardsToday: Int
}

// 2. BACKEND CONNECTOR
class RecallBackendManager {
    static let shared = RecallBackendManager()
    let serverURL = "http://YOUR_SERVER_IP:5000" // Use your ngrok or local IP
    
    // Path A & B: Send tokens to Flask
    func registerToken(userId: Int, token: String, isLiveActivity: Bool) {
        let endpoint = isLiveActivity ? "/register-live-activity" : "/register-device"
        guard let url = URL(string: serverURL + endpoint) else { return }
        
        let body: [String: Any] = [
            "user_id": userId,
            "activity_token": token // Flask expects this key for Path B
        ]
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONSerialization.data(withJSONObject: body)
        
        URLSession.shared.dataTask(with: request) { data, _, error in
            if let error = error { print("Error syncing with Flask: \(error)") }
            else { print("Successfully synced token with backend!") }
        }.resume()
    }
}

// 3. LIVE ACTIVITY CONTROLLER (Path B)
class StudySessionManager {
    func startStudySession(question: String) {
        // Check if the device supports Live Activities
        guard ActivityAuthorizationInfo().areActivitiesEnabled else { return }
        
        let attributes = RecallAttributes(totalCardsToday: 10)
        let initialState = RecallAttributes.ContentState(question: question, progress: 0.1)
        
        do {
            // Start the activity and request a push token for Path B
            let activity = try Activity.request(
                attributes: attributes,
                content: .init(state: initialState, staleDate: nil),
                pushType: .token // This is critical for remote updates from Flask
            )
            
            // Listen for the push token and send it to Flask
            Task {
                for await token in activity.pushTokenUpdates {
                    let tokenString = token.map { String(format: "%02x", $0) }.joined()
                    RecallBackendManager.shared.registerToken(userId: 1, token: tokenString, isLiveActivity: true)
                }
            }
        } catch {
            print("Failed to start Live Activity: \(error.localizedDescription)")
        }
    }
}

// 4. NOTIFICATION SETUP (Path A)
class NotificationDelegate: NSObject, UNUserNotificationCenterDelegate {
    func setupNotifications() {
        let center = UNUserNotificationCenter.current()
        center.delegate = self
        
        center.requestAuthorization(options: [.alert, .sound, .badge]) { granted, _ in
            if granted {
                DispatchQueue.main.async {
                    // In a real app, use UIApplication.shared.registerForRemoteNotifications()
                    print("Notification permission granted.")
                }
            }
        }
        
        // Define Action Buttons for Path A
        let easyAction = UNNotificationAction(identifier: "EASY_ACTION", title: "Easy", options: [])
        let hardAction = UNNotificationAction(identifier: "HARD_ACTION", title: "Hard", options: [])
        
        let category = UNNotificationCategory(
            identifier: "RECALL_CATEGORY",
            actions: [easyAction, hardAction],
            intentIdentifiers: [],
            options: []
        )
        
        center.setNotificationCategories([category])
    }
    
    // Handle the button clicks
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        let cardId = response.notification.request.content.userInfo["card_id"] as? Int ?? 0
        let quality = response.actionIdentifier == "EASY_ACTION" ? 5 : 2
        
        // Send the result to Flask /review/<id>
        print("User marked card \(cardId) as quality \(quality)")
        completionHandler()
    }
}